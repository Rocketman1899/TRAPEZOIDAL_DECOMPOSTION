%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Landon Williams, May 28 2021 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clc 
clear all

x = TrapDecompPath(.45,.38,.55,.55)
%The funciton TrapDecompPath uses trapezoidal decomposition to create a 
%Navigatable path within the given free workspace[1,1].The output is the 
%path generated by the program from point (x1,y1) to (x2,y2). Enter points
%as following TrapDecompPath(x1,y1,x2,y2). 0 < [x1,y1,x2,y2] < 1 If points 
%are not in the free workspace an error will appear. 

animatedRobot(x)

function [RobotPath]= TrapDecompPath(startx,starty,goalx,goaly)

start = [startx starty];
goal = [goalx goaly];


%searchArea is the amount of surrounding nodes the robot looks at before choosing
%its next move. Adjustment to searchArea can lead to more efficient paths
%Keep within a range of (2-10) 
searchArea =3;


% Chair 1 Vertice Locations
p1 = [0.1558219178	0.5256410256];
p2 = [0.3030821918	0.543956044];
p3 = [0.3184931507	0.3736263736];
p4 = [0.1729452055	0.3663003663];
Chair1 = round([p1; p2; p3; p4],3,'significant');

% Chair 2 Vertice Locations
p5 =[0.2962328767	0.1813186813];
p6 =[0.4160958904	0.07142857143];
p7 =[0.5154109589	0.184981685];
p8 =[0.3904109589	0.2967032967];
Chair2 = round([p5; p6; p7; p8],3,'significant');

% Chair 3 Vertice Locations
p9  = [0.7808219178	0.6245421245];
p10 = [0.6695205479	0.7655677656];
p11 = [0.5325342466	0.619047619];
p12 = [0.6198630137	0.5054945055];
Chair3 = round([p10; p11; p12; p9],3,'significant');

%Sofa 1 Vertice Locations
p13 = [0.5462328767	0.9230769231];
p14 = [0.2568493151	0.6868131868];
p15 = [0.345890411	0.5604395604];
p16 = [0.6369863014	0.7985347985];
Sofa1 = round([p13; p14; p15; p16],3,'significant');

%Sofa 2 Vertice Locations
p17 = [0.34589041095890405, 0.5616375633498921];
p18 = [0.5222602739726027, 0.31406179437001347];
p19 = [0.6181506849315068, 0.3944722514927994];
p20 = [0.44178082191780815, 0.6402165186411761];
Sofa2 = round([p17; p18; p19; p20],3,'significant');

%Sofa 3 Vertice Locations
p21 = [0.522260274	0.315018315];
p22 = [0.8082191781	0.5531135531];
p23 = [0.9006849315	0.4267399267];
p24 = [0.6113013699	0.1904761905];
Sofa3 = round([p21; p22; p23; p24],3,'significant');


%Concatenaes all of the Obstacle Vertices
Obverts = [Chair1;Chair2;Chair3;Sofa1;Sofa2;Sofa3];


xverts = Obverts(:,1);
yverts = Obverts(:,2);


%Obstacle Setup of inpoly
X_ob1 = Chair1(:,1);
X_ob2 = Chair2(:,1);
X_ob3 = Chair3(:,1);
X_ob4 = Sofa1(:,1);
X_ob5 = Sofa2(:,1);
X_ob6 = Sofa3(:,1);

Y_ob1 = Chair1(:,2);
Y_ob2 = Chair2(:,2);
Y_ob3 = Chair3(:,2);
Y_ob4 = Sofa1(:,2);
Y_ob5 = Sofa2(:,2);
Y_ob6 = Sofa3(:,2);


yloc = 0; %Y location
Vertcount = 1;
colcount = 1; 
savecount = 1;
%% Checks all vertices Prouces points
%This loop looks at every Y-location o obstacle vertice and creates points 
%where the obstacle boundary is intersected
 while Vertcount<length(xverts) 
 
     if round(yloc) == 1.0000
        Vertcount = Vertcount+1;
        yloc = 0;   
     end 
     
    AllcheckS = 0;  
    while yloc < 1
        xloc = xverts(Vertcount);
        AllCheck = 0; %Pre Sets Allcheck to off
        Obcheck1 = inpolygon( xloc,yloc, X_ob1,Y_ob1);
        Obcheck2 = inpolygon( xloc,yloc,X_ob2,Y_ob2);
        Obcheck3 = inpolygon( xloc,yloc,X_ob3,Y_ob3);
        Obcheck4 = inpolygon( xloc,yloc,X_ob4,Y_ob4);
        Obcheck5 = inpolygon( xloc,yloc, X_ob5,Y_ob5);
        Obcheck6 = inpolygon( xloc,yloc,X_ob6,Y_ob6);

        AllCheck = Obcheck1+ Obcheck2+ Obcheck3+ Obcheck4+ Obcheck5+ Obcheck6; % Checks all of the  obstacles

        %If it detecs an obstacle it saves the point where it enters and leaves
        %the obstacle boundary

        if AllCheck  >=1 || AllcheckS >=1
            condition = (AllCheck - AllcheckS) ~= 0;
            if condition == 1
                ysave(savecount,:)=  yloc;
                xsave(savecount,:) = xloc;
                savecount = savecount +1;
            end
        end
        
        yloc = yloc + 0.001;
        AllcheckS =AllCheck;
    end
 end 
 

xold = 1;
yold = 0;
for i = 1:length(xsave)
    xcurrent = xsave(i);
    ycurrent = ysave(i);

    if i<123
        yfuture = ysave(i+1);
        xfuture = xsave(i+1);
    else
        yfuture = ysave(i);
        xfuture = xsave(i);
    end

    if xcurrent == xold
        if (xfuture == xcurrent)
            segpoint(i) = (ycurrent+yold)/2;%Midpoint between obstacles
        elseif (yfuture<ycurrent) && (xfuture > xcurrent)
            segpoint(i) = (1+ycurrent)/2; %Starts from 1
        end
    end

    if xcurrent ~= xold
        if yold > ycurrent
            segpoint(i) = ycurrent/2; %Starts from 0

        end
    end

    if i >1
        ss = segpoint(i-1);
        if ss == 0
            segpoint(i-1) = (1+yold)/2;
        end
    end
    yold = ycurrent;
    xold = xcurrent;
end

for j = 1:length(segpoint)
    AllCheck = 0; %Pre Sets Allcheck to off
    Obcheck1 = inpolygon( xsave(j),segpoint(j), X_ob1,Y_ob1);
    Obcheck2 = inpolygon( xsave(j),segpoint(j),X_ob2,Y_ob2);
    Obcheck3 = inpolygon(xsave(j),segpoint(j),X_ob3,Y_ob3);
    Obcheck4 = inpolygon( xsave(j),segpoint(j),X_ob4,Y_ob4);
    Obcheck5 = inpolygon( xsave(j),segpoint(j), X_ob5,Y_ob5);
    Obcheck6 = inpolygon( xsave(j),segpoint(j),X_ob6,Y_ob6);

    AllCheck = Obcheck1+ Obcheck2+ Obcheck3+ Obcheck4+ Obcheck5+ Obcheck6;

    if AllCheck > 0
        segpoint(j) = 0;
    end

end

% Removes all  unwanted values / adds some needed values at workspace edges
vv = find(~segpoint);
segpoint(vv) =[];
xseg =xsave;
xseg(vv) = [];
yseg = segpoint';
rem =[9,35,15,23];
xseg(rem) = [];
yseg(rem) = [];
yseg = [.5; .5; yseg];
xseg = [.05 ;.95;xseg];



%Checks if Start an goal point are in the free workspace
 AllCheck = 0; %Pre Sets Allcheck to off
 Obcheck1 = inpolygon( startx,starty, X_ob1,Y_ob1); 
 Obcheck2 = inpolygon( startx,starty,X_ob2,Y_ob2); 
 Obcheck3 = inpolygon(startx,starty,X_ob3,Y_ob3); 
 Obcheck4 = inpolygon( startx,starty,X_ob4,Y_ob4); 
 Obcheck5 = inpolygon( startx,starty, X_ob5,Y_ob5);  
 Obcheck6 = inpolygon( startx,starty,X_ob6,Y_ob6);  
 
 AllCheck = Obcheck1+ Obcheck2+ Obcheck3+ Obcheck4+ Obcheck5+ Obcheck6;
 if AllCheck > 0
     error('Start point is within obstacle boundary.Choose a point within the free workspace')
 end
 
 AllCheck = 0; %Pre Sets Allcheck to off
 Obcheck1 = inpolygon( goalx,goaly, X_ob1,Y_ob1); 
 Obcheck2 = inpolygon( goalx,goaly,X_ob2,Y_ob2); 
 Obcheck3 = inpolygon(goalx,goaly,X_ob3,Y_ob3); 
 Obcheck4 = inpolygon( goalx,goaly,X_ob4,Y_ob4); 
 Obcheck5 = inpolygon( goalx,goaly, X_ob5,Y_ob5);  
 Obcheck6 = inpolygon( goalx,goaly,X_ob6,Y_ob6);  
 
 AllCheck = Obcheck1+ Obcheck2+ Obcheck3+ Obcheck4+ Obcheck5+ Obcheck6;
 if AllCheck > 0
     error('Goal point is within obstacle boundary.Choose a point within the free workspace ')
 end
 
 
xseg = [xseg;goalx];
yseg = [yseg; goaly];
x1 = startx;
y1 = starty;
j =1;
finalnodedist =1;
xpath = xseg;
ypath = yseg;

 
mm =1;
while x1~= goalx || y1~=goaly
%  disgoal1= sqrt((x1-goalx)^2 + (y1-goaly)^2) ;
 % Finds All the distances from the current node to all the nodes
vv = length(xpath);
disnode = [];
for r = 1:(vv)
    x2 = xpath(r); %Sets up x values of segment array
    y2 = ypath(r); %Sets up y values of segment array
    disnode(r) = sqrt((x2-x1)^2 + (y2-y1)^2);  %Distance between nodes     
end        
sorted = sort(disnode); %Sorts from lowest to highest
lowst = sorted(1:searchArea); %Finds the lowest values
ceil = max(lowst); %Find the max of the lowest vsalues 
lowN = find(disnode <= ceil); %Finds indices for the nearest points
lowN = lowN(1:searchArea);

% Searches for Distance Away from goal
for i = 1:searchArea
k = lowN(i);   %Sets up to parse segment array via indices for the 5 neares points
xn = xpath(k); %X of nearest point
yn = ypath(k); %Y of nearest point
goaldist = sqrt((xn-goalx)^2 + (yn-goaly)^2); %Calculates distance
con1(i,:) = [goaldist,k]; %Distance and indice of seg point
end 
distFromGoalNode = sortrows(con1,2);   %Sorts by seg point array location 


% Searches for Distance Away from current point
for s = 1:length(lowN)
m = lowN(s);
xm =xpath(m);
ym =ypath(m);
curdist = sqrt((xm-x1)^2 + (ym-y1)^2);
con2(s,:) = [curdist,m];
end
distFromCurrentNode = sortrows(con2,2);  %Sorts by seg point array location 

ptspread = distFromCurrentNode(:,1)+distFromGoalNode(:,1);
topNodes = [distFromCurrentNode(:,2) ptspread];
sortedTopNodes = sortrows(topNodes,2);

    u = 1;
for x = 1:length(sortedTopNodes)
 ind = sortedTopNodes(u,1);
 if mm ==1   
     xvec = linspace(startx,xpath(ind),300);
     yvec = linspace(starty,ypath(ind),300);
 else   
 xvec = linspace(bestindx(mm-1),xpath(ind),300);
 yvec = linspace(bestindy(mm-1),ypath(ind),300);
 end
 AllCheckl = 0; %Pre Sets Allcheck to off
 Obcheck1 = inpolygon( xvec,yvec, X_ob1,Y_ob1); 
 Obcheck2 = inpolygon( xvec,yvec,X_ob2,Y_ob2); 
 Obcheck3 = inpolygon( xvec,yvec,X_ob3,Y_ob3); 
 Obcheck4 = inpolygon( xvec,yvec,X_ob4,Y_ob4); 
 Obcheck5 = inpolygon( xvec,yvec, X_ob5,Y_ob5);  
 Obcheck6 = inpolygon( xvec,yvec,X_ob6,Y_ob6);  
 AllCheckl = Obcheck1+ Obcheck2+ Obcheck3+ Obcheck4+ Obcheck5+ Obcheck6;
 Allcheckl = max( AllCheckl);
 if   Allcheckl  > 0 
     sortedTopNodes(u,:) = [];
     u = u-2;
 end 
 u = u + 1;
 if u == 0
     u =1;
 end
end


gg = sortedTopNodes(1,1);
bestindx(mm) = xpath(gg); 
bestindy(mm) = ypath(gg);
x1 = bestindx(mm);
y1 = bestindy(mm);
% 
 xpath(gg) = [];
 ypath(gg) = [];


mm =mm+1 ;  
end

 pathx = [startx bestindx];
 pathy = [starty bestindy];

 for i = 1:(length(pathx)-1)
anipathx(:,i) = linspace(pathx(i),pathx(i+1),2); 
anipathy(:,i) = linspace(pathy(i),pathy(i+1),2) ;
 end
anipathx=reshape(anipathx,[],1);
anipathy =reshape(anipathy,[],1);
RobotPath = [anipathx anipathy]; % This array contains all that is needed for the animation

figure(1)
plot(xseg(:,1),yseg(:,1),'.r','MarkerSize',10)
hold on 
plot(xsave(:,1),ysave(:,1),'+k','MarkerSize',10)
axis square
plot(startx,starty,'or','MarkerSize',10,'MarkerFaceColor',[.2 .6 .70])
plot(goalx,goaly,'or','MarkerSize',10,'MarkerFaceColor',[.2 .6 .70])
fill(Chair1(:, 1) , Chair1(:,2), 'r');
fill(Chair2(:, 1) , Chair2(:,2), 'k');
fill(Chair3(:, 1) , Chair3(:,2), 'g');
fill(Sofa1(:, 1) , Sofa1(:,2), 'b');
fill(Sofa2(:, 1) , Sofa2(:,2), 'b');
fill(Sofa3(:, 1) , Sofa3(:,2), 'b');
plot(pathx,pathy,'-k','MarkerSize',15)
end
function [] = animatedRobot(RobotPath)  %Input Path Vector Data as a 2 column array

RobotPathx = (RobotPath(:,1));
RobotPathy = (RobotPath(:,2));

g = plot(RobotPathx(1), RobotPathy(1), 'o', 'MarkerSize' ,8, 'MarkerFaceColor', 'k');
filename = 'PortGIF4.gif'
for f = 1:length(RobotPathx);
        set(g, 'Xdata', RobotPathx(f),'Ydata', RobotPathy(f));
    drawnow;
     robotani = getframe;
     im = frame2im(robotani);
      [imind,cm] = rgb2ind(im,256);
    if f == 1;
          imwrite(imind,cm,filename,'gif', 'Loopcount',inf);
      else
          imwrite(imind,cm,filename,'gif','WriteMode','append','DelayTime',.000000001);
    end
end
movie(robotani)
end
